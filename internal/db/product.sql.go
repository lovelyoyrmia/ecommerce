// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: product.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (
    pid,
    name,
    description,
    category,
    price,
    stock
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, pid, name, description, stock, price, category
`

type CreateProductParams struct {
	Pid         string      `json:"pid"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	Category    pgtype.Int4 `json:"category"`
	Price       int32       `json:"price"`
	Stock       int32       `json:"stock"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.Pid,
		arg.Name,
		arg.Description,
		arg.Category,
		arg.Price,
		arg.Stock,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Pid,
		&i.Name,
		&i.Description,
		&i.Stock,
		&i.Price,
		&i.Category,
	)
	return i, err
}

const getCountProducts = `-- name: GetCountProducts :one
SELECT COUNT(*) as count_product FROM products
`

func (q *Queries) GetCountProducts(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getCountProducts)
	var count_product int64
	err := row.Scan(&count_product)
	return count_product, err
}

const getProductCategory = `-- name: GetProductCategory :one
SELECT name
FROM product_categories
WHERE name = $1
LIMIT 1
`

func (q *Queries) GetProductCategory(ctx context.Context, name string) (string, error) {
	row := q.db.QueryRow(ctx, getProductCategory, name)
	err := row.Scan(&name)
	return name, err
}

const getProductDetails = `-- name: GetProductDetails :one
SELECT
    products.pid, products.name, products.description,
    product_categories.name as category_name, products.stock,
    products.price
FROM products
LEFT JOIN product_categories
ON products.category = product_categories.id
WHERE pid = $1
`

type GetProductDetailsRow struct {
	Pid          string      `json:"pid"`
	Name         string      `json:"name"`
	Description  pgtype.Text `json:"description"`
	CategoryName pgtype.Text `json:"category_name"`
	Stock        int32       `json:"stock"`
	Price        int32       `json:"price"`
}

func (q *Queries) GetProductDetails(ctx context.Context, pid string) (GetProductDetailsRow, error) {
	row := q.db.QueryRow(ctx, getProductDetails, pid)
	var i GetProductDetailsRow
	err := row.Scan(
		&i.Pid,
		&i.Name,
		&i.Description,
		&i.CategoryName,
		&i.Stock,
		&i.Price,
	)
	return i, err
}

const getProducts = `-- name: GetProducts :many
SELECT
    products.pid, products.name, products.description,
    product_categories.name as category_name, products.stock,
    products.price
FROM products
LEFT JOIN product_categories
ON products.category = product_categories.id
LIMIT $1
OFFSET $2
`

type GetProductsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetProductsRow struct {
	Pid          string      `json:"pid"`
	Name         string      `json:"name"`
	Description  pgtype.Text `json:"description"`
	CategoryName pgtype.Text `json:"category_name"`
	Stock        int32       `json:"stock"`
	Price        int32       `json:"price"`
}

func (q *Queries) GetProducts(ctx context.Context, arg GetProductsParams) ([]GetProductsRow, error) {
	rows, err := q.db.Query(ctx, getProducts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductsRow{}
	for rows.Next() {
		var i GetProductsRow
		if err := rows.Scan(
			&i.Pid,
			&i.Name,
			&i.Description,
			&i.CategoryName,
			&i.Stock,
			&i.Price,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByCategory = `-- name: GetProductsByCategory :many
SELECT
    products.pid, products.name, products.description,
    product_categories.name as category_name, products.stock,
    products.price
FROM products
LEFT JOIN product_categories
ON products.category = product_categories.id
WHERE product_categories.name = $1
`

type GetProductsByCategoryRow struct {
	Pid          string      `json:"pid"`
	Name         string      `json:"name"`
	Description  pgtype.Text `json:"description"`
	CategoryName pgtype.Text `json:"category_name"`
	Stock        int32       `json:"stock"`
	Price        int32       `json:"price"`
}

func (q *Queries) GetProductsByCategory(ctx context.Context, name string) ([]GetProductsByCategoryRow, error) {
	rows, err := q.db.Query(ctx, getProductsByCategory, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductsByCategoryRow{}
	for rows.Next() {
		var i GetProductsByCategoryRow
		if err := rows.Scan(
			&i.Pid,
			&i.Name,
			&i.Description,
			&i.CategoryName,
			&i.Stock,
			&i.Price,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
